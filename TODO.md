# Project: Morphogenesis - CA-NEAT

## Goal

The primary goal of this project is to reproduce the results of the "CA-NEAT: Evolved
Compositional Pattern Producing Networks for Cellular Automata Morphogenesis and Replication" paper.
We will be re-implementing the core concepts of the paper from scratch to gain a deeper
understanding of the underlying mechanisms.

## High-Level Plan

The project is divided into two main phases:

1.  **Phase 1: Implement CPPN (Compositional Pattern Producing Networks)**
2.  **Phase 2: Implement NEAT (NeuroEvolution of Augmenting Topologies)**

---

## Phase 1: Implement CPPN

In this phase, we will focus on building the "brain" of our cellular automata, the CPPN.

- [x] **Create the `Morf::CPPN` module:**
  - This module will contain all the classes related to the CPPN implementation.

- [x] **Implement `Morf::CPPN::Node`:**
  - Represents a neuron in the network.
  - Should have an activation function.

- [x] **Implement `Morf::CPPN::Connection`:**
  - Represents a connection between two nodes.
  - Should have a weight.

- [x] **Implement `Morf::CPPN::Network`:**
  - Represents the entire CPPN.
  - Should hold the nodes and connections.
  - Should have a method to evaluate the network for a given set of inputs.

- [x] **Implement Activation Functions:**
  - Create a set of activation functions that can be used by the CPPN nodes.
  - We have implemented `sigmoid` and `identity`.

- [x] **Integrate CPPN with the Cellular Automata:**
  - Created a `Morf::CPPN::Brain` class that uses a CPPN to calculate the next state of a cell.
  - Created a `Morf::CPPN::Sensor` class that provides input to the brain.

- [x] **Create a CPPN Experiment:**
  - This experiment visualizes the patterns generated by a hand-coded CPPN.
  - We created the following classes:
    - `Morf::CPPN::NetworkFactory` to build the network.
    - `Morf::Experiments::CPPN::Brain` to drive the cell's state.
    - `Morf::Experiments::CPPN::Seed` to set up the initial grid state.
    - `Morf::Experiments::CPPN::CellView` for visualization.
    - `Morf::Experiments::CPPN::Experiment` to tie everything together.
  - **Next Step:** Manually test the experiment and verify that it runs correctly.

- [x] **Review Module Naming:**
  - In some cases, a Ruby module was named `CPPN` and in others `Cppn`.
  - After reviewing the Ruby style guide, we decided to use `CPPN` for the module name.
  - All modules have been updated to use the `CPPN` naming convention.

- [x] **Review Accessors:**
  - Classes in `Morf::CPPN` module implemented attribute accessors.
  - Reviewed all accessors and removed unnecessary ones from `Morf::CPPN::Network` to improve encapsulation.

- [x] **Implement All Activation Functions:**
  - Implemented all activation functions listed in the "CA-NEAT" paper.

---

## Phase 2: Implement NEAT

Once we have a working CPPN implementation, we will move on to implementing the NEAT algorithm to
evolve the CPPNs.

- [x] **Create the `Morf::NEAT` module:**
  - This module will contain all the classes related to the NEAT implementation.

- [x] **Implement `Morf::NEAT::Genome`:**
  - Represents the genetic encoding of a CPPN.

- [x] **Implement `Morf::NEAT::NodeGene`:**
  - Represents a node in the CPPN genome.
  - It should have an `id`, a `type` (`input`, `output`, `hidden`), and an `activation_function`.

- [x] **Implement `Morf::NEAT::ConnectionGene`:**
  - Represents a connection between two nodes in the CPPN genome.
  - It should have an `in_node_id`, an `out_node_id`, a `weight`, an `enabled` status, and an
    `innovation_number`.

- [x] **Implement `Morf::NEAT::Population`:**
  - Manages a population of genomes.

- [x] **Implement `Morf::NEAT::Speciation`:**
  - Implements the logic for dividing the population into species based on topological similarity.

- [x] **Implement `Morf::NEAT::Reproduction`:**
  - [x] Implemented the crossover operator.
  - [x] Implement mutation operators.

- [x] **Refactor for Discrete States and Implement Fitness Function**
  - The goal is to support multiple discrete states for cells (e.g., dead, blue, white, red)
    determined by a "winner-take-all" mechanism from a multi-output CPPN. Cell states will be
    represented by integers for generality.

  - [x] **Phase 1: Refactor for Integer-Based Discrete States**
    - [x] **Update `Morf::Cell`:**
      - No changes are needed. The `Morf::Cell` is generic and its state is determined by the `brain`.
      - The "winner-take-all" logic, which converts a brain's multiple outputs into a single
        integer state, is correctly implemented in `Morf::CPPN::Brain`.
      - This allows for different brain implementations with different state types.
    - [x] **Update `Morf::GridView`:**
      - The `initialize` method will accept a `color_map` (e.g., an array of colors).
      - It will pass the `color_map` down to the `CellView` instances it creates.
    - [x] **Update `CellView` Classes:**
      - The `initialize` method will accept a `color_map`.
      - The rendering logic will use the cell's integer state as an index to look up the correct
        color in the `color_map`.
    - [x] **Update Experiments:**
      - The experiment setup (e.g., in `Morf::Experiments::CPPN::Experiment`) will be updated to
        pass the `color_map` to the `GridView`.

  - [x] **Phase 2: Implement `Morf::NEAT::Fitness`**
    - [x] **Create `Morf::NEAT::Fitness` module and `PatternTarget` class:**
      - Create `lib/morf/neat/fitness.rb`.
      - Create `spec/morf/neat/fitness_spec.rb`.
    - [x] **Implement `PatternTarget` Class:**
      - It will be initialized with a `target_pattern` (a 2D array of **integers**).
      - The `evaluate(grid)` method will compare the integer state of each cell with the integer in
        the target pattern.
      - Fitness will be calculated as `correct_cells / total_cells`.

- [x] **Refactor `Morf::Grid` to use a Brain Factory**
  - The goal is to allow a single brain instance, configured with a specific genome's network, to be
    shared across all cells in a grid during a fitness evaluation. This is a cleaner approach than
    dynamically creating brain classes.
  - [x] **Phase 1: Refactor `Morf::Grid`**
    - [x] Modify the `initialize` method to accept a `brain_factory` object instead of a
      `brain_class`.
    - [x] Update the `initialize_grid` method to use `brain_factory.create_brain` to create brain
      instances for cells.
  - [x] **Phase 2: Create `Morf::DefaultBrainFactory`**
    - [x] Create the `lib/morf/default_brain_factory.rb` file.
    - [x] The factory will take a `brain_class` in its constructor and its `create_brain` method
      will call `.new` on that class to maintain the old behavior.
    - [x] Create a corresponding spec file.
  - [x] **Phase 3: Update Existing Code**
    - [x] Find all usages of `Morf::Grid.new` in the codebase.
    - [x] Update them to wrap the existing `brain_class` in the new `Morf::DefaultBrainFactory`.
      This includes `spec/morf/grid_spec.rb` and any existing experiment files.

- [ ] **Create a NEAT Experiment:**
  - This experiment will use the NEAT algorithm to evolve a population of CPPNs to generate the
    French Flag pattern using a traditional cellular automaton model.

  - [ ] **Phase 1: Define Experiment Configuration & Sensor**
    - [x] Create `lib/morf/experiments/neat/constants.rb` to store experiment parameters (population
      size, generations, grid size, etc.).
    - [x] In `constants.rb`, define `FRENCH_FLAG_PATTERN`, `SEED_PATTERN`, and `COLOR_MAP`.
    - [x] Use existing `Morf::CPPN::Sensor` for Moore neighborhood.
    - [x] Create `Morf::NEAT::NetworkBuilder` to construct a CPPN from a genome.

  - [ ] **Phase 2: Implement Fitness Evaluation**
    - [ ] Create `lib/morf/experiments/neat/fitness_evaluator.rb`. This class will manage the
      fitness evaluation for a single genome.
    - [ ] It will be initialized with a genome and the target pattern.
    - [ ] It will create a `Morf::CPPN::Brain` from the genome using the `NetworkBuilder`.
    - [ ] It will create a specialized brain factory that returns the same brain instance.
    - [ ] It will set up a grid with the `SEED_PATTERN` using the specialized brain factory.
    - [ ] It will run the 30-iteration development loop. In each iteration, it will use
      `Morf::NEAT::Fitness::PatternTarget` to calculate the raw fitness.
    - [ ] It will find the maximum raw fitness (`x`) across all iterations.
    - [ ] It will calculate and return the final scaled fitness using the formula
      `f(x) = x * (exp(5*x)) / exp(5)`.

  - [ ] **Phase 3: Implement the Main Experiment Runner**
    - [ ] Create `lib/morf/experiments/neat/runner.rb` to manage a single, complete experiment run.
    - [ ] The `run` method will contain the main loop for 100 generations.
    - [ ] Inside the loop, it will:
      - Use `FitnessEvaluator` to calculate the fitness for every genome in the population.
      - Log the generation number, best/average fitness, and species count.
      - Perform selection, reproduction, and mutation to create the next generation.
    - [ ] After the loop, it will identify the best genome of the entire run and save it to a
      timestamped file using `Marshal.dump`.

  - [ ] **Phase 4: Create Executables**
    - [ ] Create a script `bin/run_neat_experiment` that starts the experiment by calling
      `Morf::Experiments::NEAT::Runner.new.run`.
    - [ ] Create a script `bin/visualize_genome` that takes a path to a dumped genome file, loads
      it, and runs its development on a grid, rendering the result with `Morf::GridView`.

  - [ ] **Phase 5: Testing**
    - [ ] Add basic RSpec tests for the new classes (`fitness_evaluator`, `runner`) to
      ensure they are wired correctly.

## Notes

- We will be following a TDD/BDD approach, so we will be writing tests for all the new classes.
- We will keep the existing directory structure and conventions.
- We will commit our changes frequently with clear and descriptive messages.
- We will commit our changes after each step of the implementation.
