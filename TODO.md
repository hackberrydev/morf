# Project: Morphogenesis - CA-NEAT

## Goal

The primary goal of this project is to reproduce the results of the "CA-NEAT: Evolved
Compositional Pattern Producing Networks for Cellular Automata Morphogenesis and Replication" paper.
We will be re-implementing the core concepts of the paper from scratch to gain a deeper
understanding of the underlying mechanisms.

## High-Level Plan

The project is divided into two main phases:

1.  **Phase 1: Implement CPPN (Compositional Pattern Producing Networks)**
2.  **Phase 2: Implement NEAT (NeuroEvolution of Augmenting Topologies)**

---

## Phase 1: Implement CPPN

In this phase, we will focus on building the "brain" of our cellular automata, the CPPN.

- [x] **Create the `Morf::CPPN` module:**
  - This module will contain all the classes related to the CPPN implementation.

- [x] **Implement `Morf::CPPN::Node`:**
  - Represents a neuron in the network.
  - Should have an activation function.

- [x] **Implement `Morf::CPPN::Connection`:**
  - Represents a connection between two nodes.
  - Should have a weight.

- [x] **Implement `Morf::CPPN::Network`:**
  - Represents the entire CPPN.
  - Should hold the nodes and connections.
  - Should have a method to evaluate the network for a given set of inputs.

- [x] **Implement Activation Functions:**
  - Create a set of activation functions that can be used by the CPPN nodes.
  - We have implemented `sigmoid` and `identity`.

- [x] **Integrate CPPN with the Cellular Automata:**
  - Created a `Morf::CPPN::Brain` class that uses a CPPN to calculate the next state of a cell.
  - Created a `Morf::CPPN::Sensor` class that provides input to the brain.

- [x] **Create a CPPN Experiment:**
  - This experiment visualizes the patterns generated by a hand-coded CPPN.
  - We created the following classes:
    - `Morf::CPPN::NetworkFactory` to build the network.
    - `Morf::Experiments::CPPN::Brain` to drive the cell's state.
    - `Morf::Experiments::CPPN::Seed` to set up the initial grid state.
    - `Morf::Experiments::CPPN::CellView` for visualization.
    - `Morf::Experiments::CPPN::Experiment` to tie everything together.
  - **Next Step:** Manually test the experiment and verify that it runs correctly.

- [x] **Review Module Naming:**
  - In some cases, a Ruby module was named `CPPN` and in others `Cppn`.
  - After reviewing the Ruby style guide, we decided to use `CPPN` for the module name.
  - All modules have been updated to use the `CPPN` naming convention.

- [x] **Review Accessors:**
  - Classes in `Morf::CPPN` module implemented attribute accessors.
  - Reviewed all accessors and removed unnecessary ones from `Morf::CPPN::Network` to improve encapsulation.

- [x] **Implement All Activation Functions:**
  - Implemented all activation functions listed in the "CA-NEAT" paper.

---

## Phase 2: Implement NEAT

Once we have a working CPPN implementation, we will move on to implementing the NEAT algorithm to
evolve the CPPNs.

- [x] **Create the `Morf::NEAT` module:**
  - This module will contain all the classes related to the NEAT implementation.

- [x] **Implement `Morf::NEAT::Genome`:**
  - Represents the genetic encoding of a CPPN.

- [x] **Implement `Morf::NEAT::NodeGene`:**
  - Represents a node in the CPPN genome.
  - It should have an `id`, a `type` (`input`, `output`, `hidden`), and an `activation_function`.

- [x] **Implement `Morf::NEAT::ConnectionGene`:**
  - Represents a connection between two nodes in the CPPN genome.
  - It should have an `in_node_id`, an `out_node_id`, a `weight`, an `enabled` status, and an
    `innovation_number`.

- [x] **Implement `Morf::NEAT::Population`:**
  - Manages a population of genomes.

- [x] **Implement `Morf::NEAT::Speciation`:**
  - Implements the logic for dividing the population into species based on topological similarity.

- [x] **Implement `Morf::NEAT::Reproduction`:**
  - [x] Implemented the crossover operator.
  - [x] Implement mutation operators.

- [ ] **Refactor for Discrete States and Implement Fitness Function**
  - The goal is to support multiple discrete states for cells (e.g., dead, blue, white, red)
    determined by a "winner-take-all" mechanism from a multi-output CPPN. Cell states will be
    represented by integers for generality.

  - [ ] **Phase 1: Refactor for Integer-Based Discrete States**
    - [ ] **Update `Morf::Cell`:**
      - The cell's `@state` will be an **integer**.
      - The `update` method will set the cell's state to the **index** of the highest value in the
        array returned by the brain.
    - [ ] **Update `Morf::GridView`:**
      - The `initialize` method will accept a `color_map` (e.g., an array of colors).
      - It will pass the `color_map` down to the `CellView` instances it creates.
    - [ ] **Update `CellView` Classes:**
      - The `initialize` method will accept a `color_map`.
      - The rendering logic will use the cell's integer state as an index to look up the correct
        color in the `color_map`.
    - [ ] **Update Experiments:**
      - The experiment setup (e.g., in `Morf::Experiments::CPPN::Experiment`) will be updated to
        pass the `color_map` to the `GridView`.

  - [ ] **Phase 2: Implement `Morf::NEAT::Fitness`**
    - [ ] **Create `Morf::NEAT::Fitness` module and `PatternTarget` class:**
      - Create `lib/morf/neat/fitness.rb`.
      - Create `spec/morf/neat/fitness_spec.rb`.
    - [ ] **Implement `PatternTarget` Class:**
      - It will be initialized with a `target_pattern` (a 2D array of **integers**).
      - The `evaluate(grid)` method will compare the integer state of each cell with the integer in
        the target pattern.
      - Fitness will be calculated as `correct_cells / total_cells`.

- [ ] **Create a NEAT Experiment:**
  - Create a new experiment in `lib/morf/experiments/neat/`.
  - This experiment will use the NEAT algorithm to evolve a population of CPPNs to generate a
    target pattern.

## Notes

- We will be following a TDD/BDD approach, so we will be writing tests for all the new classes.
- We will keep the existing directory structure and conventions.
- We will commit our changes frequently with clear and descriptive messages.
- We will commit our changes after each step of the implementation.
